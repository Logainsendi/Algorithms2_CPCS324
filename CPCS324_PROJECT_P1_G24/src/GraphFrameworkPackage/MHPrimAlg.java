package GraphFrameworkPackage;

import java.util.ArrayList;
import java.util.PriorityQueue;

public class MHPrimAlg extends MSTAlgorithm {

    // attributes
    private Graph graph;
    private ArrayList<Edge> MSTresultList = new ArrayList<>();
    private int totalCost = 0;
    long runTime;

    // constructer
    public MHPrimAlg() {
    }

    public int getTotalCost() {
        return totalCost;
    }

    public ArrayList<Edge> getMSTresultList() {
        return MSTresultList;
    }

    // applying min heap prim algorithm on a given graph
    public void applyMHPrim(Graph graph) {

        // start time
        long startTime = System.currentTimeMillis();

        Vertex currentVertex = graph.getVertices()[0]; // Current vertex will hold vertex 0.

        PriorityQueue<Edge> pq = new PriorityQueue<Edge>(); //PriorityQueue to store edges weights

        // Loop through vertices array (|V|-1)
        for (int i = 0; i < graph.getVerticesNo() - 1; i++) {

            // Loop through adjacent vertices of this vertex
            for (int j = 0; j < currentVertex.getAdjList().size(); j++) {
                Edge edge = currentVertex.getAdjList().get(j);
                edge.getSource().setIsVisited(true);
                // Check if its visited before adding it to the queue
                if (!edge.getTarget().isIsVisited()) {
                    pq.add(edge); 

                } 
            }
            while (!pq.isEmpty()) {
                // Remove edge with minimum-weight edge
                Edge edge = pq.remove();  

                if (!edge.getTarget().isIsVisited()) {

                    edge.getTarget().setIsVisited(true); 

                    MSTresultList.add(edge);

                    totalCost = totalCost + edge.getWeight(); 

                    currentVertex = edge.getTarget(); 
                    break; 
                } 
            } 
        } 

        long endTime = System.currentTimeMillis();

        // calculate the run time
        runTime = endTime - startTime;
    } 
  

    @Override
    public void displayResultingMST(int requirementNum) {
        // print the result
        if (requirementNum == 1) {
            System.out.println("\nThe phone network (minimum spanning tree) generated by priorit queue based prim algorithm is as follows:");

            for (int i = 0; i < MSTresultList.size(); i++) {

                Edge line = MSTresultList.get(i);

                Vertex sourceOffice = line.getSource();
                Vertex targetOffice = line.getTarget();

                sourceOffice.displayInfo();
                System.out.print(" - ");
                targetOffice.displayInfo();
                System.out.print(" : ");
                line.displayInfo();
            }

            System.out.println("The cost of designed phone network: " + getTotalCost());

        } else if (requirementNum == 2) {

            System.out.println("\nThe phone network (minimum spanning tree) generated by priority queue based prim algorithm is as follows:");
            System.out.println("The cost of designed phone network: " + getTotalCost());
            System.out.println("Run time: " + runTime + " milliseconds");
        }

    }

}
